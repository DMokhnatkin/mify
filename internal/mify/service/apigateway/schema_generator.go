package apigateway

import (
	"bytes"
	"encoding/json"
	"errors"
	"io/ioutil"
	"os"

	"github.com/chebykinn/mify/internal/mify/workspace"
	"github.com/getkin/kin-openapi/openapi3"
	"gopkg.in/yaml.v2"
)

const (
	ExtensionKey   = "x-mify-public"
	ApiGatewayName = "api-gateway"
)

// Api path -> service name
type PublicApis map[string]string

type pathsItems map[string]*openapi3.PathItem

func RegenerateSchema(workspace workspace.Context) (PublicApis, error) {
	check, err := apiGatewayExists(workspace)
	if err != nil {
		return nil, err
	}

	if !check {
		return nil, nil
	}

	gatewayGeneratedApiSchemaPath := workspace.GetApiSchemaGenAbsPath(ApiGatewayName)
	os.Remove(gatewayGeneratedApiSchemaPath)

	var res PublicApis = make(PublicApis)

	for _, goService := range workspace.GoServices {
		if goService.Name == ApiGatewayName {
			continue
		}

		apiSchemaAbsPath := workspace.GetApiSchemaAbsPath(goService.Name)
		pathItems, err := extractPublicAPI(apiSchemaAbsPath)
		if err != nil {
			return nil, err
		}

		if len(pathItems) == 0 {
			continue
		}

		for path, _ := range pathItems {
			res[path] = goService.Name
		}

		generatedApiSchemaAbsPath := workspace.GetApiSchemaGenAbsPath(ApiGatewayName)
		if err := appendApiSchema(generatedApiSchemaAbsPath, pathItems); err != nil {
			return nil, err
		}
	}

	return res, nil
}

func apiGatewayExists(workspace workspace.Context) (bool, error) {
	path := workspace.GetApiSchemaDirAbsPath(ApiGatewayName)
	if _, err := os.Stat(path); err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return false, nil
		}

		return false, err
	}

	return true, nil
}

func extractPublicAPI(apiSchemaAbsPath string) (pathsItems, error) {
	res := make(map[string]*openapi3.PathItem)

	doc, err := openapi3.NewLoader().LoadFromFile(apiSchemaAbsPath)
	if err != nil {
		return nil, err
	}

	for path, pathItem := range doc.Paths {
		var pathItemCopy openapi3.PathItem = *pathItem
		for method, operation := range pathItem.Operations() {
			if _, ok := operation.Extensions[ExtensionKey]; !ok {
				pathItemCopy.SetOperation(method, nil)
			}
		}

		if len(pathItemCopy.Operations()) > 0 {
			res[path] = &pathItemCopy
		}
	}

	return res, nil
}

func appendApiSchema(schemaAbsPath string, items pathsItems) error {
	var doc *openapi3.T = nil
	if _, err := os.Stat(schemaAbsPath); errors.Is(err, os.ErrNotExist) {
		doc = &openapi3.T{
			OpenAPI: "3.0.0",
			Info: &openapi3.Info{
				Version:     "1.0.0",
				Title:       "api-gateway",
				Description: "Generated by mify",
			},
			Paths: make(openapi3.Paths),
		}
	} else {
		doc, err = openapi3.NewLoader().LoadFromFile(schemaAbsPath)
		if err != nil {
			return err
		}
	}

	for path, pathItem := range items {
		doc.Paths[path] = pathItem
	}

	jsonBuf, err := doc.MarshalJSON()
	if err != nil {
		return err
	}

	tmp := map[string]interface{}{}
	err = json.Unmarshal(jsonBuf, &tmp)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := yaml.NewEncoder(&buf).Encode(tmp); err != nil {
		return err
	}

	err = ioutil.WriteFile(schemaAbsPath, buf.Bytes(), 0644)
	if err != nil {
		return err
	}

	return nil
}
